:source-highlighter: pygments
:toc-levels: 5
:toc: left
:toc-title: Conteúdo
:sectnums:
:dialect: latex
:icons: font

= Exercícios de Processamento Digital de Imagens =
Victor Emanuel <victorers2@gmail.com> e Vinícius Aguiar <vmaguiar@hotmail.com>

== Unidade 1
=== Trabalhando com regiões
==== Negativo da região
Esse programa derevá solicitar ao usuário as coordenadas de dois pontos localizados dentro dos limites do tamanho da imagem. $P_{1}$ e $P_{2}$ serão interpretados como os vértices opostos de um retângulo, que será exibido com a cor negativa no interior.

.regions.cpp
[source, cpp]
----
include::Unidade 1/regions.cpp[]
----

O programa apenas exibe o resultado quando executado, não salva-o. A imagem a seguir mostra a saída para $P_{1} = (50, 50)$ e $P_{2} = (200, 200)$. Note que o usuário pode digitar pontos quaisquer pois o programa verifica qual é o superior esquerdo e o inferior direito.
.Resultado de regions.cpp
image::img/regions.jpg[]


==== Translada quadrantes
O próximo, chamado de 'trocaregioes.cpp', deverá trocar os quadrantes em diagonal na imagem.

.trocaRegioes.cpp
[source, cpp]
----
include::Unidade 1/trocaRegioes.cpp[]
----

Este salva o resultado na mesma pasta em que foi executado. Abaixo uma comparação da imagem original com resultado de trocaRegioes.cpp
[.clearfix]
--
.Original
[.left]
image::img/biel.png[]
.Processada
[.left]
image::Unidade 1/resultado.png[]
--

=== Preechendo Regiões
==== Conta bolhas e buracos
.labeling.cpp
[source, cpp]
----
include::Unidade 1/labeling.cpp[]
----

Saída em texto: `Foram encontradas 21 bolhas, 7 com buraco`. OBS.: uma das bolhas tem um buraco de apenas 3 pixels não perceptível numa contagem rápida.
O programa salva as imagens geradas para fazer o processamento. Serão exibidas abaixo.
[.clearfix]
--
[.left]
.Original
image::img/bolhas.png[width=135%]
.Sem bolhas na borda
[.left]
image::Unidade 1/semborda.png[width=135%]
--
[.clearfix]
--
.Bolhas em tons de cinza
[.left]
image::Unidade 1/resultBolhas.png[width=135%]
.Buracos em tons de cinza
[.left]
image::Unidade 1/buracos.png[width=135%]
--

=== Histogramas
==== Equalização
O programa abaixo deve equalizar o histograma das imagens capturadas pela webcam. A função responsável por esse trabalho é a https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/histogram_equalization/histogram_equalization.html[Histogram Equalization], nativa do OpenCV.

.equalize.cpp
[source, cpp]
----
include::Unidade 1/equalizeCam.cpp[]
----
.Manhã ensolarada no Bloco I do setor 4, UFRN
image::img/equalizeCam.png[]

==== Detector de movimento
O segundo programa deve realizar a tarefa de um detector de movimento usando apenas os histogramas de uma imagem atual e da anterior. A comparação é feita usando a função nativa do OpenCV disponível neste link https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/histogram_comparison/histogram_comparison.html[Histogram Comparison]

.movimentoCam.cpp
[source, cpp]
----
include::Unidade 1/movimento.cpp[]
----

A saída do programa, além da imagem capturada pela webcam, é a indicação se houve movimento no momento em que é detectada. A função `compareHist()` retorna um `float` no intervalo de 0 a 1 que resulta do método de comparação usada. No código acima foi a "Bhattacharyya distance", dada por:

image::https://docs.opencv.org/2.4/_images/math/2962ee11d544acbb1a5f97d00a4a8bd24a4e1e11.png[Bhattacharyya distance, align="center"] 

NOTE: A saída deste programa não é uma imagem processada, mas apenas o texto "movimento detectado" sendo exibido em tempo real na medida em que ocorre uma variação brusca no histograma da imagem. Nenhum "print" provaria a eficácia do programa, fica a cargo do leitor testá-lo na sua máquina.


=== Filtragem no Domínio Espacial I
O único exercício desta seção é adaptar o código neste https://agostinhobritojr.github.io/tutorial/pdi/#_filtragem_no_dom%C3%ADnio_espacial_i[site] para que ele também exiba o Laplaciano do Gaussiano das imagens capturadas. O programa original já aplica esses filtros: média, Gaussiano, Laplaciano, Sobel x e Sobel y. O desafio consiste em aplicar dois desses simultaneamente.

.laplgauss.cpp
[source, cpp]
----
include::Unidade 1/laplgauss.cpp[]
----

Comparando o resultado do Laplaciano do Gaussiano com o laplaciano puro é possível notar que o primeiro tem menos ruído em relação ao segundo.

[.clearfix]
--
.Laplaciano puro
[.left]
image::img/laplace.png[]

.Laplaciano do Gaussiano
[.left]
image::img/laplgauss.png[]
--

[NOTE]
====
Adicionamos a máscara "original" que, quando convoluída com uma imagem, não altera seus pixels. Este é o elemento neutro da convolução 2D, como o $\delta (x)$ de Dirac é na convolução 1D.
[source, cpp]
----
float original[] = {0, 0, 0,
                    0, 1, 0,
                    0, 0, 0};
----
====

=== Filtragem no Domínio Espacial II
==== Aplicando filtro numa imagem
Aqui aplicaremos o efeito https://pt.wikipedia.org/wiki/Tilt-shift[Tiltshift] numa imagem qualquer roubada da internet. Foi pedido que houvesse dois controles deslizantes para que o usuário escolha os parâmetros do efeito: a largura do borrão e sua taxa de decaimento. Sendo breve, o procedimento seguido foi o mesmo descrito https://agostinhobritojr.github.io/tutorial/pdi/#_filtragem_no_dom%C3%ADnio_espacial_ii[aqui].

.tiltshift.cpp
[source, cpp]
----
include::Unidade 1/tiltshift.cpp[]
----

Na imagem exibida pelo programa, o controle de largura pode ir de 0 até metade da altura da imagem, no "tiltpraia.png" usado acima é 290. O controle de decaimento pode ir de 0 a 40 (valor arbitrário). Na prática, o decaimento só fará efeito se for $\geq$ 1, pois é o denominador de uma divisão. Infelizmente não há como mudar esse detalhe, a função https://docs.opencv.org/2.4/modules/highgui/doc/user_interface.html?highlight=createtrackbar[createTrackbar] no OpenCV não oferece muita liberdade de personalização. Na documentação vemos que o controle só trabalha com inteiros e seu valor mínimo é sempre 0, entretanto, dá para usá-lo em diversas aplicações quando se sabe a arte da gambiarra.

.Uma praia de Prado, cidade da Bahia
image::img/tiltpraia.png[]

==== Aplicando filtro num vídeo
Agora aplicando o mesmo efeito de cima em um vídeo.

.tiltshiftvideo.cpp
[source, cpp]
----
include::Unidade 1/tiltshiftvideo.cpp[]
----

[.clearfix]
--
.Imagem que multiplica original
[.left]
image::img/pondOriginal.png[,310]
.Imagem que multiplica borrada
[.left]
image:img/pondBorrada.png[,310]
--

[.clearfix]
--
.Imagem original ponderada
[.left]
image::img/original.png[,310]
.Imagem borrada ponderada
[.left]
image::img/borrada.png[,310]
--

Resultado: 

video::40E3JeNt49Q[youtube, width=90%]

== Unidade 2


